<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Rodrigo Estrella -</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<link href="./www/favicon.ico" rel="icon">
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-VMG6412QZY"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-VMG6412QZY', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>


<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="Rodrigo Estrella -">
<meta property="og:site-name" content="Rodrigo Estrella">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Rodrigo Estrella</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html">
 <span class="menu-text">Inicio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./#proyectos">
 <span class="menu-text">Proyectos</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html">
 <span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./generativeArt.html">
 <span class="menu-text">Arte Generativo</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./flowingFields.html" aria-current="page">
 <span class="menu-text">Flowing Fields</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/rodrigo-agustin-estrella/"><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/rodrigoestrellac"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div class="quarto-toggle-container">
                  <a href="" class="quarto-color-scheme-toggle nav-link" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
              </div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-layout-custom page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
<!-- main -->



<div class="intro-screen-generative2">
<div class="flowingFieldsPage">
<div class="flowingFields-title">
<p>Flowing Fields</p>
</div>
<div class="flowingFields-content">
<p><img src="www/flowingFields_66.jpeg" class="img-fluid" style="float: right; padding:1%; margin-top:-1%; margin-left:1%" width="250"></p>
<p>This is my best and most versatile generative art algorithm up to date. It is heavily inspired by <a href="https://tylerxhobbs.com/">Tyler Hobbs’</a> work in <a href="https://tylerxhobbs.com/fidenza">Fidenza</a>. It has more than 20 parameters to play with so the results can vary a lot. You can find the collection in <a href="https://opensea.io/collection/generative-app-flowing-fields">OpenSea</a>. <br> The algorithm is based on the <em>canvas_flow</em> function in the <a href="https://koenderks.github.io/aRtsy/">aRtsy package</a> developed by Koen Derks. That function draws a flowfield in the canvas using <a href="https://ggplot2.tidyverse.org/">ggplot2</a> as the core engine.<br> From that base ground I started adding parameters and features to the basic function. I will explain most of them in the next lines.</p>
<section id="stroke-style" class="level3">
<h3 data-anchor-id="stroke-style">Stroke Style</h3>
<p>One of the first features I worked on is the <em>stroke style</em>. The basic function worked with random stroke sizes and using a rounded segment to connect the coordinates of the line. With this way of plotting, the lines end up having a <em>brushstroke</em> feel. So by tweaking the code a little bit I was able to add a parameter to select whether to connect the dots using a squared stroke or a rounded one. <br> Then, I thought that the rounded strokes looked a bit similar to pipes, so I ended up adding the <em>pipes</em> and <em>pipes reverse</em> stroke styles, which consist basically in adding dots at the start or end of the lines simulating the hole of the pipes. Here the trick is that ggplot draws the lines all at once, so the holes of the pipes might look weird if the lines overlap. So to fix that the algorithm plots each pair of line-hole one by one, making the depth to feel more ‘realistic’. The same dot-line pair is used to make the <em>circle ending</em> style of stroke. The difference is that the circle is placed in both start and end of the line and it is bigger than the stroke of the line. <br> The last type of stroke style is not actually a stroke, by changing the <em>geom_segment</em> function to <em>geom_point</em> in ggplot and making the step size of the iterations fixed we get the <em>dots</em> stroke style.<br> Some examples of the types of stroke styles are shown below.</p>
<div style="display: flex; justify-content: space-around;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="www/flowingFields9.jpg" class="figure img-fluid figure-img" width="200"></p>
<p></p><figcaption class="figure-caption">Brushstroke</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="www/flowingFields6.jpg" class="figure img-fluid figure-img" width="200"></p>
<p></p><figcaption class="figure-caption">Square</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="www/flowingFields_66.jpeg" class="figure img-fluid figure-img" width="200"></p>
<p></p><figcaption class="figure-caption">Round</figcaption><p></p>
</figure>
</div>
</div>
<div style="display: flex; justify-content: space-around;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="www/flowingFields3.jpg" class="figure img-fluid figure-img" width="200"></p>
<p></p><figcaption class="figure-caption">Pipes</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="www/flowingFields50.jpg" class="figure img-fluid figure-img" width="200"></p>
<p></p><figcaption class="figure-caption">Circle Ending</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="www/flowingFields28.jpg" class="figure img-fluid figure-img" width="200"></p>
<p></p><figcaption class="figure-caption">Dots</figcaption><p></p>
</figure>
</div>
</div>
</section>
<section id="collision-check" class="level3">
<h3 data-anchor-id="collision-check">Collision Check</h3>
<p>Next I started working on the collision check for the lines drawn. Now there are three levels of collision to check (big, small and none). If it is one of the first two, the algorithm checks if the line it is currently drawing is about to collide to any of the previous lines drawn. The trick here is to also take into account the stroke size of the lines. And this is really tricky because the Flowing Fields algorithm consists of two parts, a C++ part which iterates to calculate the flow of each line, and the R algorithm that works with the color assignment and plotting of the lines. It is tricky because the C++ does not know the stroke size of the actual plotted lines and in terms of the X and Y axis. That way, the collision check has a bit of randomness, or beautiful imperfection if I may, in the way that even if the check is big, for big thick lines may still overlap. <strong>BEAUTIFUL.</strong> The pictures below show the differences between the three types of collision checks.</p>
<div style="display: flex; justify-content: space-around;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="www/flowingFields69.jpg" class="figure img-fluid figure-img" width="225"></p>
<p></p><figcaption class="figure-caption">Big</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="www/flowingFields49.jpg" class="img-fluid figure-img" width="225"></p>
<p></p><figcaption class="figure-caption">Small</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="www/flowingFields30.jpg" class="img-fluid figure-img" width="225"></p>
<p></p><figcaption class="figure-caption">None</figcaption><p></p>
</figure>
</div>
</div>
</section>
<section id="color" class="level3">
<h3 data-anchor-id="color">Color</h3>
<p>This is more of a constantly evolving feature than a discrete step. Different color palettes and ways of assign colors to the lines are constantly being added, probably because it is fun and because in many cases it is somewhat easy to add a new possibility to the algorithm. I will just comment on the ways of defining a color palette or a method to assign color to lines.</p>
<section id="color-palettes" class="level4">
<h4 data-anchor-id="color-palettes">Color palettes</h4>
<div class="quarto-figure quarto-figure-center" style="float: left; margin-top:1%; margin-right:1%">
<figure class="figure">
<p><img src="www/flowingFields39.jpg" height="200" class="figure-img"></p>
<p></p><figcaption class="figure-caption">Vegan Tacos</figcaption><p></p>
</figure>
</div>
<p>The aRtsy package has a lot of color palettes, my favorite is called Mixer 2 (I even have a printed flowfield with that palette at home). With the base ground set by Koen Derks I started experimenting with colors, the main sources of inspiration come from food, landscapes and music. That way I came up with the <em>Vegan Tacos</em>, <em>City Sunset</em> or <em>Fire Arcade</em> palettes for example. Yes, naming the palettes is also very fun.</p>
</section>
<section id="color-assignment" class="level4">
<h4 data-anchor-id="color-assignment">Color assignment</h4>
<p>The way of assigning color to the lines is also a ever evolving process. The first ways of assigning color I added are the <em>Smooth</em> ones Those just assign the color according to the mean position of the line. It can be in terms of the X or Y axis, and also in terms of a radial distance from a given point of the canvas. Color can also be assigned in terms of the starting or ending position of the line. <br></p>
<div class="quarto-figure quarto-figure-center" style="float: right; margin-top:1%; margin-left:1%">
<figure class="figure">
<p><img src="www/flowingFields65.jpg" class="img-fluid figure-img" width="200"></p>
<p></p><figcaption class="figure-caption">Smooth Strip of Color</figcaption><p></p>
</figure>
</div>
<p>The last methods added are the ones that set just a dash, a stroke or a strip of color. They just assign the color palette to a given set of lines. The coloured lines are chosen in terms of size or position. The remaining lines are painted with colors that are similar to the background of the canvas or in <em>shades of grey</em> (yup, like the book).</p>
</section>
<section id="single-stroke-color" class="level4">
<h4 data-anchor-id="single-stroke-color">Single Stroke Color</h4>
<div class="quarto-figure quarto-figure-center" style="float: left; margin-top:1%; margin-right:1%">
<figure class="figure">
<p><img src="www/flowingFields51.jpg" class="img-fluid figure-img" width="200"></p>
<p></p><figcaption class="figure-caption">Single Stroke Color</figcaption><p></p>
</figure>
</div>
<p>Inspired by the Fidenza collection I set a parameter that defines whether the lines can change color or not. If it is true, the lines can have up to three different colors. In the case of the color assignment methods that adds just a bit of color, the lines can have up to four colors, and the remaining lines can have many colors as well, but always in shades of grey or shades of the background color.</p>
<!-- ![Predominant Color](www/flowingFields69.jpg){style="float: right; margin-top:-1%; margin-left:1%" width="200"} -->
<p><br></p>
</section>
<section id="predominant-color" class="level4">
<h4 data-anchor-id="predominant-color">Predominant Color</h4>
<p>If true, a color has 2 out of 3 chances to get assigned. The rest of the palette shares the remaining chances.</p>
<p><br></p>
<p><br></p>
<p><br></p>
</section>
</section>
<section id="flow" class="level3">
<h3 data-anchor-id="flow">Flow</h3>
<p>This parameter sets the <em>flowing of the fields</em>, it sets the way the lines will move through the canvas. The initial function had many algorithms to generate the angles according to which the lines will turn. The ones that I use the most are support vector machines (SVM) and K nearest neighboors (KNN). I added the spiral and straigth flows, with their <a href="https://en.wikipedia.org/wiki/Perlin_noise">Perlin noise</a> modifications. <br> The speed of the spiral and the frequency of the perlin noise are parameters that can be modified.</p>
</section>
<section id="the-rest-of-the-fun-parameters" class="level3">
<h3 data-anchor-id="the-rest-of-the-fun-parameters">The rest of the fun parameters</h3>
<p>The rest of the parameters the Flowing Fields algorithm has to amuse ourselves are these ones:</p>
<ul>
<li><strong>Orientation</strong>: portrait or landscape</li>
<li><strong>Number of lines</strong>: the number of lines that will be drawn in the canvas.</li>
<li><strong>Iterations</strong>: number of times the C++ algorithm moves the lines.</li>
<li><strong>Max step</strong>: maximum size of the random step the lines take in each iteration.</li>
<li><strong>Empty radius</strong>: whether or not the canvas has an empty spot. That space can be filled with a circle. Position and size of that circle are also parameters.</li>
<li><strong>Maximum and minimum stroke size</strong>: range from which the stroke size of the lines are randomly drawn.</li>
<li><strong>Maximum length of the lines</strong>: the lines can be set to have a maximum length that will stop the iteration for that line.</li>
<li><strong>Size of the portion of the canvas with color</strong>: this parameter applies only in the case of the color assignment method that only adds color to some lines.</li>
<li><strong>Margin</strong>: whether the canvas has margin or not.</li>
<li><strong>Signature</strong>: you can put your signature at the bottom of the artwork. My artistic name is <em>Rodriguin</em>.</li>
</ul>
<p>The algorithm itself is wrapped inside an <a href="https://shiny.rstudio.com/">R Shiny</a> app (<em>The Generative App</em>) that makes it easier to play with it. That’s all there is to the Flowing Fields algorithm and the Generative App. Hope you found it interesting. <br> Remember you can check the full <a href="https://opensea.io/collection/generative-app-flowing-fields">collection in OpenSea</a>.</p>
<p><br></p>
</section>
</div>
</div>
</div>




<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
    var links = window.document.querySelectorAll('a:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">Esta página está hecha con <a href="https://quarto.org/">Quarto</a></div>   
  </div>
</footer>



<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>